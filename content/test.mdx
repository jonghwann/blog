---
title: "테스트 포스트"
date: "2025-09-30"
tags: ["test"]
series: "Next.js 블로그 만들기"
---

최근 프로젝트에서 페이스북 소셜 로그인 기능을 구현하는 업무를 맡게 되었습니다. 기존에는 구글과 애플 로그인이 이미 구현되어 있었고, 서버에서 nonce 와 state 값을 발급받아 사용하는 하이브리드 플로우 방식을 사용하고 있었습니다. 그래서 저는 페이스북 역시 동일한 방식으로 구현할 수 있을 것이라 예상했죠.
하지만 페이스북 공식 문서를 확인해보니, 예상과 달리 클라이언트에서 추가적인 보안 조치를 적용해야만 액세스 토큰을 얻을 수 있다는 점을 알게 되었습니다. 바로 PKCE가 적용된 OIDC 인증 방식이 필요하다는 것이었습니다.
물론 클라이언트에서 추가 인증 과정을 생략하고 액세스 토큰을 받아오는 방법도 있었지만, 이는 보안상 취약점이 있어 권장되지 않는 방식이었습니다. 그래서 가능하다면 PKCE가 적용된 OIDC 인증 방식을 써야 한다는 점을 알게 되었죠.
사실 OAuth의 전체적인 흐름에 대해 잘 알지 못했던 터라, 낯선 용어들을 접하니 막막함이 느껴지더라구요. 그렇지만 회사 업무인 만큼 팀 동료들에게도 이 개념을 잘 설명할 수 있어야 했기에 학습에 대한 동기부여로도 이어졌습니다. 그래서 본격적인 기능 구현에 앞서 열심히 자료를 찾아보며 해당 개념을 이해하려고 노력했고, 결과적으로 코드 리뷰도 잘 마치고 기능 구현까지 성공적으로 완료할 수 있었습니다.
그래서 오늘은 제가 직접 경험한 페이스북 로그인 구현 사례를 바탕으로, OIDC와 PKCE를 활용해 클라이언트 측에서 어떻게 안전하게 사용자 인증을 구현할 수 있는지 알아보고자 합니다. OIDC와 PKCE의 개념을 이해하고 실제 적용 방법이 궁금하신 분들께 도움이 되기를 바랍니다.

## 개념 정리
PKCE가 적용된 OIDC 방식의 소셜 로그인을 다루는 만큼, 필수적으로 등장하는 개념인 OAuth 2.0, OIDC (OpenID Connect), 그리고 PKCE (Proof Key for Code Exchange) 에 대해 간단히 정리해보겠습니다.

### OAuth
2.0 은 권한 부여(Authorization)에 사용되는 프로토콜로, 클라이언트(애플리케이션)가 사용자를 대신하여, 또는 애플리케이션 자체가 특정 자원에 대해 제한된 접근 권한을 얻을 수 있도록 하는 역할을 합니다.
구글 드라이브에 접근 권한을 요구하는 SNS 서비스를 이용하는 시나리오를 한 번 떠올려봅시다.

## OIDC
이러한 이유로 등장한 OIDC(OpenID Connect) 는 OAuth 2.0 위에 구축된 프로토콜로, 사용자 인증을 위한 표준화된 방법을 제공합니다. OIDC는 사용자 인증과 ID 정보를 액세스 토큰과 함께 ID 토큰(ID Token) 형태로 제공합니다.
그런데 OIDC는 왜 필요한 걸까요? 단순히 OAuth 2.0으로 발급받은 토큰으로 로그인한 계정의 정보를 API로 조회하면 충분하지 않을까요?
이는 OAuth 2.0의 근본적인 목적과 관련이 있습니다. OAuth 2.0의 액세스 토큰은 특정 자원에 접근할 수 있는 권한만을 증명할 뿐, 그 토큰을 사용하는 사람이 정말 토큰의 주인인지는 보장하지 않습니다. 만약 공격자가 액세스 토큰을 탈취한다면, 다른 사람인 척하며 자원에 접근할 수도 있겠죠. 이처럼 액세스 토큰과 프로필 API의 조합만으로는 인증된 사용자가 접근한다는 사실을 온전히 보장하기 어렵습니다.
즉, OAuth 2.0의 액세스 토큰과 프로필 API는 사용자의 리소스 접근 만 보장할 뿐, 사용자가 인증되었고 누구인지 는 보장하지 않습니다. 그래서 ID 토큰이라는 추가적인 인증 정보가 필요하며, 이 정보를 ID 토큰 형태로 제공하는 것이 OIDC의 핵심입니다.

### ID
토큰은 JWT 형식으로 만들어집니다. 덕분에 클라이언트 애플리케이션은 구글, 페이스북 등 여러 제공자를 OIDC로 연동하더라도, 각각의 사용자 정보를 일관된 방식으로 안전하게 처리할 수 있다는 장점이 있습니다.